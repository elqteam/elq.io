<!DOCTYPE>
<html lang="en">
<head>
    <title>Elq &ndash; The element queries library.</title>
    <link rel="stylesheet" type="text/css" href="css/style.css">

    <script src="js/modernizr/modernizr.js"></script>
    <script src="js/Chart.js/Chart.min.js"></script>
    <script src="js/tabs/index.js"></script>
    <script src="js/elq/elq.js"></script>
    <script src="js/elq/elq-breakpoints.js"></script>
    <script src="js/elq/elq-mirror.js"></script>
    <script src="js/main.js"></script>

</head>
<body>

    <section id="intro">
        <div class="container">
            <header>
                <img src="img/elq-logo-v1.svg" class="logo">
            </header>

            <p>Element queries is the last puzzle piece for truly modular and responsive web design. This is our approach to this very interesting problem. Ladies and Gentle&shy;men, <em>Meet Elq.</em></p>

            <div class="buttons">
                <div class="button-version-wrapper">
                    <button class="btn btn-big btn-yellow">Install</button>
                    <label>v0.4.1</label>
                </div>

                <button class="btn btn-big btn-white">Docs</button>
            </div>
        </div>
    </section>

    <section>
        <div class="container">
            <header>
                <h1>Why Element Queries?</h1>
            </header>

            <p>Element queries are not for the faint hearted (read: not suitable for all projects). If your web app consists of modules that are (or should be) responsive – then this is most probably something for you! Otherwise, move on and come back another time :)</p>
        </div>
    </section>

    <hr class="section-separator">

    <section>
        <div class="container">
            <header>
                <h1>Why ELQ?</h1>
            </header>

            <p>Since element queries have not been standardized (and not implemented in browsers), developers need to resort to JavaScript to provide element queries. There are numerous libraries that enable element queries in different ways, but here are the main selling points to why we believe ELQ is the best solution:</p>

            <ul>
                <li><em class="green">Super-fast</em> element resize detection</li>
                <li>Extensibility through <em class="green">plugins</em></li>
                <li><em class="green">Batch processed</em> updates of elements <em class="green">breakpoint states</em> (to avoid layout thrashing).</li>
                <li><em class="green">Compatibility</em> with browsers (IE8+, Opera 12+, etc).</li>
                <li><em class="green">Compatibility</em> with existing code (conforms to HTML, JS and CSS specs).</li>
                <li>A <em class="green">runtime cycle detection system</em></li>
                <li>Allowing style encapsulation of responsive elements (for <em class="green">nested</em> responsive modules).</li>
            </ul>

            <p>For a very detailed description of ELQ and element queries, read the <a href="http://kth.diva-portal.org/smash/get/diva2:850230/FULLTEXT01.pdf" title="'ELQ: Extensible Element Queries for Modular Responsive Web Components' by Lucas Wiener.">Master's Thesis</a>. The API and architecture is somewhat outdated, but the Thesis is still relevant for understanding ELQ.</p>

            <center><a class="btn btn-blue" href="http://kth.diva-portal.org/smash/get/diva2:850230/FULLTEXT01.pdf" title="'ELQ: Extensible Element Queries for Modular Responsive Web Components' by Lucas Wiener.">Read Master's Thesis</a></center>

            <div class="note">
                <p>ELQ is currently in beta. Therefore, API changes may occur frequently. We really appreciate feedback such as GitHub issues and pull requests.</p>

                <p>File size is a bit big at the moment (237 KB, 16 KB minified + gzip). In the future, we will remove the lodash dependency, reducing the size to something like (70 KB, 6 KB minified + gzip).</p>
            </div>
        </div>
    </section>


    <hr class="section-separator">

    <section>
        <div class="container">
            <header>
                <h1>Stop... It´s Demo time!</h1>
            </header>

            <h2>The most basic example</h2>

            <p>A simple component which changes color and border-radius depending on its size.</p>

            <center><button resize-target="demo-box-1" resize-sizes="80 150 250 350 450" class="btn btn-blue">Resize</button></center>
            <br>

            <div id="demo-box-1" class="demo-box">
                <div class="demo-module" elq elq-breakpoints elq-breakpoints-widths="100 200 300 400"></div>
            </div>


            <div class="tab-container">
                <div class="tabs">
                    <a class="tab active">HTML</a>
                    <a class="tab">LESS</a>
                    <a class="tab">CSS</a>
                </div>
                <div class="tab-panes">
                    <div class="tab-pane active">
                        <script src="https://gist.github.com/nadangergeo/be64419b938cc622ca30e9917767411f.js"></script>
                    </div>
                    <div class="tab-pane">
                        <script src="https://gist.github.com/nadangergeo/82207ab3025fa4084c79bcb4c999b067.js"></script>
                    </div>
                    <div class="tab-pane" >
                        <script src="https://gist.github.com/nadangergeo/581c922a987903ef062517b14675a74b.js"></script>
                    </div>
                </div>
            </div>            


            <!-- <center><button class="btn btn-blue">More demos</button></center> -->

            <br>
            <br>

            <h2>Nested modules</h2>
            <p>The modules are naturally nestable. Let's try nesting our test-module.</p>

            <center><button resize-target="demo-box-2" resize-sizes="150 250 350 450" class="btn btn-blue">Resize</button></center>
            <br>

            <div id="demo-box-2" class="demo-box">
                <div class="demo-module" elq elq-breakpoints elq-breakpoints-widths="100 200 300 400">
                    <div class="demo-module" elq elq-breakpoints elq-breakpoints-widths="100 200 300 400"></div>
                </div>
            </div>

            <!-- <center><button class="btn btn-blue">More demos</button></center> -->

        </div>
    </section>

    <hr class="section-separator">

    <section>
        <div class="container">
            <header>
                <h1>Documentation</h1>
            </header>

            <p>We haven't had time to write proper docs yet. What follows is really a minimal explanation of the API.</p>

            <h2>Usage example</h2>

            <p>Once the <code>dist/elq.js</code> file is included into the HTML (it is built with UMD, so include it as you wish) it exposes a global function Elq. This is a constructor that creates ELQ instances. It is recommended to only use one instance per application.</p>

            <script src="https://gist.github.com/nadangergeo/c191942899436f55de5c2d08f440e230.js"></script>

            <p>
                The main idea is to annotate elements with breakpoints of interest so that children can be conditionally styled in CSS by targeting the different breakpoint states. ELQ is bundled with three plugins as default, that let you annotate breakpoints as attributes of your elements like so:
            </p>

            <script src="https://gist.github.com/nadangergeo/9ccf405e087fd6798b5712e13077db36.js"></script>

            <p>When ELQ has processed the element, it will always have two classes, one for each breakpoint, that tells if the size of the element is greater or lesser than each breakpoint. For instance, if the element is 400 pixels wide, the element has the two classes <code>elq-min-width-300px</code> and <code>elq-max-width-500px</code>. Similarly, if the element is 200 pixels wide the element the classes are instead <code>elq-max-width-300px</code> and <code>elq-max-width-500px</code>. So for each breakpoint only the <code>min/max</code> part changes.</p>

            <p>It may seem alien that the classes describe that the width of the element is both maximum 300 and 500 pixels. This is because we have taken a user-centric approach, so that when using the classes in CSS the API is similar to media queries (while sticking to the CSS-spec). However, developers are free to change this API at will as <em>Elq</em> is plugin-based.</p>

            <p>Now that we have defined the breakpoints of the element, we can conditionally style it by using the classes:</p>

            <div class="tab-container">
                <div class="tabs">
                    <a class="tab active">LESS</a>
                    <a class="tab">CSS</a>
                </div>
                <div class="tab-panes">
                    <div class="tab-pane active">
                        <script src="https://gist.github.com/nadangergeo/e8e592e84dd872d06832464b07fd3181.js"></script>
                    </div>
                    <div class="tab-pane">
                        <script src="https://gist.github.com/nadangergeo/522234cf181c3f48f6dec34c4879b1ed.js"></script>
                    </div>
                </div>
            </div>

            <p>This API is sufficient for applications that do not need nested breakpoint elements, and similar features is provided by related libraries. However, using such API in responsive modules still limits the reusability since the modules then may not exist in an outer responsive context.</p>

            <p>The reason this API is not sufficient for nested modules is because there is no way to limit the CSS matching search of the selectors. The selector <code>.foo.elq-max-width-500px p</code> specifies that all paragraph elements should have white text if any ancestor breakpoints element is above 500 pixels wide. Since the ancestor selector may match elements outside of the module, such selectors are dangerous to use in the context of responsive modules. The problem may be somewhat reduced by more specific selectors and such, but it cannot be fully solved for arbitrary styling.</p>

            <p>To solve this problem, we provide a plugin that let us define elements to "mirror" the breakpoints classes of the nearest ancestor breakpoints element. Then, the conditional style of the mirror element may be written as a combinatory selector that is relative to the nearest ancestor breakpoints element.</p>

            <p>Let's expand our example HTML to include to nested modules, that uses the <code>mirror</code> API.</p>

            <script src="https://gist.github.com/nadangergeo/d8f40075e5619f9904bb333278c038e1.js"></script>

            <p>As the paragraph elements are mirroring the nearest .foo ancestor, we can now write CSS in the following encapsulated way:</p>
        </div>
    </section>

    <footer>
        <div class="container">
            <p class="ack">
                Elq is the result of <a href="#">Lucas Wiener</a>'s master's thesis at The Royal Institute of Technonolgy (KTH) in Stockholm, Sweden. The thesis was supervised by Tomas Ekholm and Stefan Sennerö at the consulting firm <a href="https://www.evry.se/">Evry</a>, and Philipp Haller at KTH.
                The website and logotype is designed by <a href="https://twitter.com/nadangergeo">Nadan Gergeo</a> at the creative bureau <a href="http://blimp.se">Blimp</a>.
                Special thanks to <a href="https://responsiveimages.org/">RICG</a> (W3C) and <a href="https://github.com/marcoscaceres">Marcos Caceres</a> at Mozilla.
            </p>

            <nav>
                <ul>
                    <li><a href="#">Docs</a></li>
                    <li><a href="#">Get started</a></li>
                    <li><a href="#">Demos</a></li>
                    <li><a href="#">Plugins</a></li>
                    <li><a href="#">Issues</a></li>
                    <li><a href="#">About</a></li>
                </ul>
            </nav>

        <p class="version">Currently v0.4.1</p>

    </footer>

</body>
</html>