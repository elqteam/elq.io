<!DOCTYPE>
<html lang="en">
<head>
    <title>Elq &ndash; The element queries library.</title>
    <link rel="stylesheet" type="text/css" href="css/style.css">

    <script src="js/modernizr/modernizr.js"></script>
    <script src="js/Chart.js/Chart.min.js"></script>
    <script src="js/tabs/index.js"></script>
    <script src="js/elq/elq.js"></script>
    <script src="js/elq/elq-breakpoints.js"></script>
    <script src="js/elq/elq-mirror.js"></script>
    <script src="js/main.js"></script>

</head>
<body>

    <section id="intro">
        <div class="container">
            <header>
                <img src="img/elq-logo-v1.svg" class="logo">
            </header>

            <p>Ladies and gentle&shy;men, <em>meet ELQ</em> &ndash; The classy approach to Element Queries for modular and responsive components.</p>

            <div class="buttons">
                <div class="button-version-wrapper">
                    <button class="btn btn-big btn-yellow">Install</button>
                    <label>v0.4.1</label>
                </div>

                <button class="btn btn-big btn-white">Docs</button>
            </div>
        </div>
    </section>

    <section>
        <div class="container">
            <header>
                <h1>Why Element Queries?</h1>
            </header>

            <p>Element queries are not for the faint hearted (read: not suitable for all projects). If your web app consists of modules that are (or should be) responsive – then this is most probably something for you! Otherwise, move on and come back another time :)</p>
        </div>
    </section>

    <hr class="section-separator">

    <section>
        <div class="container">
            <header>
                <hgroup>
                    <h1>Why ELQ?</h1>
                    <h2>Short answer: because it's classy.</h2>
                </hgroup>
            </header>            

            <p>Since element queries have not been standardized (and not implemented in browsers), developers need to resort to JavaScript to provide element queries. There are numerous libraries that enable element queries in different ways, but here are the main selling points to why we believe ELQ is the best solution:</p>

            <ul>
                <li><em class="green">Super-fast</em> element resize detection</li>
                <li>Extensibility through <em class="green">plugins</em></li>
                <li><em class="green">Batch processed</em> updates of elements <em class="green">breakpoint states</em> (to avoid layout thrashing).</li>
                <li><em class="green">Compatibility</em> with browsers (IE8+, Opera 12+, etc).</li>
                <li><em class="green">Compatibility</em> with existing code (conforms to HTML, JS and CSS specs).</li>
                <li>A <em class="green">runtime cycle detection system</em></li>
                <li>Allowing style encapsulation of responsive elements (for <em class="green">nested</em> responsive modules).</li>
            </ul>

            <p>For a very detailed description of ELQ and element queries, read the <a href="http://kth.diva-portal.org/smash/get/diva2:850230/FULLTEXT01.pdf" title="'ELQ: Extensible Element Queries for Modular Responsive Web Components' by Lucas Wiener.">Master's Thesis</a>. The API and architecture is somewhat outdated, but the Thesis is still relevant for understanding ELQ.</p>

            <br>
            <br>

            <center><a class="btn btn-blue" href="http://kth.diva-portal.org/smash/get/diva2:850230/FULLTEXT01.pdf" title="'ELQ: Extensible Element Queries for Modular Responsive Web Components' by Lucas Wiener.">Read Master's Thesis</a></center>

            <br>
            <br>

            <div class="note">
                <p>ELQ is currently in beta. Therefore, API changes may occur frequently. We really appreciate feedback such as GitHub issues and pull requests.</p>

                <p>File size is a bit big at the moment (237 KB, 16 KB minified + gzip). In the future, we will remove the lodash dependency, reducing the size to something like (70 KB, 6 KB minified + gzip).</p>
            </div>
        </div>
    </section>


    <hr class="section-separator">

    <section>
        <div class="container">
            <header>
                <h1>Stop... It´s Demo time!</h1>
            </header>

            <h2>The most basic example</h2>

            <p>A simple component which changes color and border-radius depending on its size.</p>

            <center><button resize-target="demo-box-1" resize-sizes="80 150 250 350 450" class="btn btn-blue">Resize</button></center>
            <br>

            <div id="demo-box-1" class="demo-box">
                <div class="demo-module" elq elq-breakpoints elq-breakpoints-widths="100 200 300 400"></div>
            </div>


            <div class="tab-container">
                <div class="tabs">
                    <a class="tab active">HTML</a>
                    <a class="tab">LESS</a>
                    <a class="tab">CSS</a>
                </div>
                <div class="tab-panes">
                    <div class="tab-pane active">
                        <script src="https://gist.github.com/nadangergeo/be64419b938cc622ca30e9917767411f.js"></script>
                    </div>
                    <div class="tab-pane">
                        <script src="https://gist.github.com/nadangergeo/82207ab3025fa4084c79bcb4c999b067.js"></script>
                    </div>
                    <div class="tab-pane" >
                        <script src="https://gist.github.com/nadangergeo/581c922a987903ef062517b14675a74b.js"></script>
                    </div>
                </div>
            </div>            


            <!-- <center><button class="btn btn-blue">More demos</button></center> -->

            <br>
            <br>

            <h2>Nested modules</h2>
            <p>The modules are naturally nestable. Let's try nesting our demo-module.</p>

            <center><button resize-target="demo-box-2" resize-sizes="150 250 350 450" class="btn btn-blue">Resize</button></center>
            <br>

            <div id="demo-box-2" class="demo-box">
                <div class="demo-module" elq elq-breakpoints elq-breakpoints-widths="100 200 300 400">
                    <div class="demo-module" elq elq-breakpoints elq-breakpoints-widths="100 200 300 400"></div>
                </div>
            </div>

            <!-- <center><button class="btn btn-blue">More demos</button></center> -->

        </div>
    </section>

    <hr class="section-separator">

    <section>
        <div class="container">
            <header>
                <h1>Documentation</h1>
            </header>

            <div class="note">
                <p>We haven't had time to write proper docs yet. What follows is really a minimal explanation of the API.</p>
            </div>

            <h2>Usage example</h2>

            <p>Once the <code>dist/elq.js</code> file is included into the HTML (it is built with UMD, so include it as you wish) it exposes a global function Elq. This is a constructor that creates ELQ instances. It is recommended to only use one instance per application.</p>

            <script src="https://gist.github.com/nadangergeo/c191942899436f55de5c2d08f440e230.js"></script>

            <p>
                The main idea is to annotate elements with breakpoints of interest so that children can be conditionally styled in CSS by targeting the different breakpoint states. ELQ is bundled with three plugins as default, that let you annotate breakpoints as attributes of your elements like so:
            </p>

            <script src="https://gist.github.com/nadangergeo/9ccf405e087fd6798b5712e13077db36.js"></script>

            <p>When ELQ has processed the element, it will always have two classes, one for each breakpoint, that tells if the size of the element is greater or lesser than each breakpoint. For instance, if the element is 400 pixels wide, the element has the two classes <code>elq-min-width-300px</code> and <code>elq-max-width-500px</code>. Similarly, if the element is 200 pixels wide the element the classes are instead <code>elq-max-width-300px</code> and <code>elq-max-width-500px</code>. So for each breakpoint only the <code>min/max</code> part changes.</p>

            <p>It may seem alien that the classes describe that the width of the element is both maximum 300 and 500 pixels. This is because we have taken a user-centric approach, so that when using the classes in CSS the API is similar to elememt queries. However, developers are free to change this API at will as <code>Elq</code> is plugin-based.</p>

            <p>Now that we have defined the breakpoints of the element, we can conditionally style it by using the classes:</p>

            <div class="tab-container">
                <div class="tabs">
                    <a class="tab active">LESS</a>
                    <a class="tab">CSS</a>
                </div>
                <div class="tab-panes">
                    <div class="tab-pane active">
                        <script src="https://gist.github.com/nadangergeo/e8e592e84dd872d06832464b07fd3181.js"></script>
                    </div>
                    <div class="tab-pane">
                        <script src="https://gist.github.com/nadangergeo/522234cf181c3f48f6dec34c4879b1ed.js"></script>
                    </div>
                </div>
            </div>

            <p>This API is sufficient for applications that do not need nested breakpoint elements, and similar features is provided by related libraries. However, using such API in responsive modules still limits the reusability since the modules then may not exist in an outer responsive context.</p>

            <p>The reason this API is not sufficient for nested modules is because there is no way to limit the CSS matching search of the selectors. The selector <code>.foo.elq-max-width-500px p</code> specifies that all paragraph elements should have white text if any ancestor breakpoints element is above 500 pixels wide. Since the ancestor selector may match elements outside of the module, such selectors are dangerous to use in the context of responsive modules. The problem may be somewhat reduced by more specific selectors and such, but it cannot be fully solved for arbitrary styling.</p>

            <p>To solve this problem, we provide a plugin that let us define elements to "mirror" the breakpoints classes of the nearest ancestor breakpoints element. Then, the conditional style of the mirror element may be written as a combinatory selector that is relative to the nearest ancestor breakpoints element.</p>

            <p>Let's expand our example HTML to include to nested modules, that uses the <code>mirror</code> API.</p>

            <script src="https://gist.github.com/nadangergeo/d8f40075e5619f9904bb333278c038e1.js"></script>

            <p>As the paragraph elements are mirroring the nearest .foo ancestor, we can now write CSS in the following encapsulated way:</p>

            <script src="https://gist.github.com/nadangergeo/be1df092c0b0d470320fedc8e644f323.js"></script>

            <p>Since we in the previous examples have annotated elements manually, the power and flexibility of the API have not been properly displayed. Only when combined with JavaScript, things get more interesting. To be continued...</p>
        </div>
    </section>

    <hr class="section-separator">

    <section>
        <div class="container">
            <header>
                <h1>Public API</h1>
            </header>

            <p>An ELQ instance exposes the following public methods:</p>

            <h3><code>elq.getVersion()</code></h3>
            <p>Returns the version of instance.</p>

            <hr class="subsection-separator">

            <h3><code>elq.use(plugin)</code></h3>
            <p>Registers a plugin to be used by the instance. Parameter is required to be a <code class="simple green">plugin definition object.</code></p>

            <hr class="subsection-separator">

            <h3><code>elq.using(plugin)</code></h3>
            <p>Tells if the given plugin has been registered or not. Parameter can be a plugin name (of type string) or a plugin definition object.</p>
            <p>Returns a <code class="simple green">Boolean</code>..</p>

            <hr class="subsection-separator">

            <h3><code>elq.activate(elements)</code></h3>
            <p>Activates the given collection of elements. This triggers ELQ to perform its work so that all element queries are updated. Plugins are invoked, so that they can perform their logic. Resize listeners are also installed when propriate. Elements may be activated multiple times.</p>
            <p>Parameter can be any collection of elements, and also accepts a single element. The are assumed to be ELQ-elements and it is not recommended to activate non-ELQ elements.</p>

            <hr class="subsection-separator">

            <h3><code>elq.listenTo([element], event, callback)</code></h3>
            <p>Registers a callback to be called for an event of an element. The element parameter is option, and if omitted the callback will be called when the event is emitted for any element.</p>


        </div>
    </section>

    <hr class="section-separator">

    <section>
        <div class="container">
            <header>
                <h1>Options</h1>
            </header>

            <h3><code>cycleDetection</code></h3>
            <ul>
                <li>Type: <code class="simple green">Boolean</code></li>
                <li>Default: <code class="simple green">Boolean</code></li>
            </ul>
            <p>When enabled, the cycle detection system tries to detect cyclic rules and breaks them if needed. When a cycle is detected, a console warning is printed. This may be helpful during development to catch cycles.</p>

            <hr class="subsection-separator">

            <h3><code>defaultUnit</code></h3>
            <ul>
                <li>Type: <code class="simple green">String</code></li>
                <li>Valid values: <code class="green">"px"</code> <code class="green">"em"</code> <code class="green">"rem"</code></li>
                <li>Default: <code class="green">"px"</code></li>
            </ul>
            <p>Sets the default unit for all breakpoints that do not have a unit postfix. For instance, if defaultUnit is set to <code class="green">"em"</code>, the breakpoint <code class="simple green">300</code> is interpreted as <code class="simple green">300em</code> while breakpoint <code class="simple green">500px</code> is still interpreted as <code class="simple green">500px.</code></p>


        </div>
    </section>

    <hr class="section-separator">

    <section>
        <div class="container">
            <header>
                <h1>Architecture & Plugins</h1>
            </header>

            <p>One our of contributions is to allow ELQ to be easily extended with plugins. For example, if annotating HTML is undesired it is possible to create a plugin that instead parses CSS. Likewise, if adding breakpoint classes to element is undesired it is possible to create a plugin that does something else when a breakpoint state of an element has changed. In order to enable such powerful behavior altering by plugins, extensibility has been the main focus when designing the ELQ architecture.</p>

            <h2>Plugin Definition Object</h2>
            <p>A plugin is defined by a <code class="simple green">plugin definition object</code> and has the following structure:</p>
            <script src="https://gist.github.com/nadangergeo/5cabaf45771c4e2ffa4e8fb949d33c0e.js"></script>

            <p>All of the methods are invoked when registered to an ELQ instance. The <code>getName</code> and <code>getVersion</code> methods tells the name and version of the plugin. The <code>isCompatible</code> tells if the plugin is compatible with the ELQ instance that it is registered to. In the <code>make</code> method the plugin may initialize itself to the ELQ instance and return an object that defines the API accessible by ELQ and other plugins.</p>

            <p>When necessary, ELQ invokes certain methods of the plugin API, if implemented, to let plugins decide the behavior of the system. Those methods are the following:</p>

            <h3><code>activate(element)</code></h3>
            <p>Called when an element is requested to be activated, in order for plugins to initialize listeners and element properties.</p>

            <hr class="subsection-separator">

            <h3><code>getElements(element)</code></h3>
            <p>Called in order to let plugins reveal extra elements to be activated in addition to the given element.</p>

            <hr class="subsection-separator">

            <h3><code>getBreakpoints(element)</code></h3>
            <p>Called to retrieve the current breakpoints of an element.</p>

            <hr class="subsection-separator">

            <h3><code>applyBreakpointStates(element, breakpointStates)</code></h3>
            <p>Called to apply the given breakpoint states of an element.</p>            

            <br>
            <br>
            <br>

            <h3>In addition, plugins may also listen to the following ELQ events:</h3>

            <h3><code class="blue">resize(element)</code></h3>
            <p>Emitted when an ELQ element has changed size.</p>

            <hr class="subsection-separator">

            <h3><code class="blue">breakpointStatesChanged(element, breakpointStates)</code></h3>
            <p>Emitted when an element has changed breakpoint states (e.g., when the width of an element changed from being narrower than a breakpoint to being wider).</p>
        </div>
    </section>


    <hr class="section-separator">

    <section>
        <div class="container">
            <header>
                <h1>Flow</h1>
            </header>

            <p>There are two main flows of the ELQ system; activating an element and updating an element. When ELQ is requested to activate an element, the following flow occurs:</p>

            <ol class="spacey">
                <li>The element is initialized by installing properties and a system handling listeners.</li>
                <li>The <code>getElements</code> method of all plugins is called to retrieve any additional elements to activate. Additional elements will go through an own flow.</li>
                <li>The <code>activate</code> method of all plugins is called so that plugin specific initialized may occur.</li>
                <li>If any plugin has requested ELQ to detect resize events of the element, an resize detector is installed.</li>
                <li>The element is passed through the update flow.</li>
            </ol>

            <p>The update flow is as follows:</p>

            <ol class="spacey">
                <li>The <code>getBreakpoints</code> method of all plugins is called to retrieve all breakpoints of the element.</li>
                <li>Breakpoint states are calculated.</li>
                <li>If any state has changed since the previous update:
                    <ol>
                        <li>Cycle detection is performed.</li>
                        <li>The <code>applyBreakpoints</code> method of all plugins is called.</li>
                        <li>The <code class="blue">breakpointStatesChanged</code> event is emitted.</li>
                    </ol>
                </li>
            </ol>

            <p>Of course, there are options to disable some of the steps such as cycle detection and applying breakpoints. In addition to being triggered by the start flow and plugins, it is also triggered by element resize events.</p>


        </div>
    </section>

    <hr class="section-separator">

    <section>
        <div class="container">
            <header>
                <h1>Example Plugin Implementation</h1>
            </header>

            <p>The API that enables developers to annotate breakpoints in HTML, as described in the usage section, is implemented as two plugins. One plugin parses the breakpoints of the element attributes and one plugin applies the breakpoint classes. The simplified code of the <code>make</code> method of the parsing plugin is as following:</p>

            <script src="https://gist.github.com/nadangergeo/0b533a69b903f37590e4867deb2e8177.js"></script>

            <p>The applying plugin simply implements the <code>applyBreakpoints</code> method to alter the <code class="simple green">className</code> property of the element by the given breakpoint states.</p>
            
        </div>
    </section>

    <footer>
        <div class="container">
            <p class="ack">
                Elq is the result of <a href="#">Lucas Wiener</a>'s master's thesis at The Royal Institute of Technonolgy (KTH) in Stockholm, Sweden. The thesis was supervised by Tomas Ekholm and Stefan Sennerö at the consulting firm <a href="https://www.evry.se/">Evry</a>, and Philipp Haller at KTH.
                The website and logotype is designed by <a href="https://twitter.com/nadangergeo">Nadan Gergeo</a> at the creative bureau <a href="http://blimp.se">Blimp</a>.
                Special thanks to <a href="https://responsiveimages.org/">RICG</a> (W3C) and <a href="https://github.com/marcoscaceres">Marcos Caceres</a> at Mozilla.
            </p>

            <nav>
                <ul>
                    <li><a href="#">Docs</a></li>
                    <li><a href="#">Get started</a></li>
                    <li><a href="#">Demos</a></li>
                    <li><a href="#">Plugins</a></li>
                    <li><a href="#">Issues</a></li>
                    <li><a href="#">About</a></li>
                </ul>
            </nav>

        <p class="version">Currently v0.4.1</p>

    </footer>

</body>
</html>